<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ECMAScript 6 新特性]]></title>
    <url>%2F2017%2F05%2F25%2FECMAScript%206%20%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[部署进度 目前ES6的支持度已经越来越高了，超过90%的 ES6 语法特性都实现了。关于各大浏览器的最新版本，对 ES6 的支持可以查看kangax.github.io/es5-compat-table/es6/。 Node 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。它对 ES6 的支持度更高。除了那些默认打开的功能，还有一些语法功能已经实现了，但是默认没有打开。使用下面的命令，可以查看 Node 已经实现的 ES6 特性。 $ node --v8-options | grep harmony 上面命令的输出结果，会因为版本的不同而有所不同。 使用阮一峰写的工具ES-Checker用来检查各种运行环境对 ES6 的支持情况。访问ruanyf.github.io/es-checker,可以看到您的浏览器支持 ES6 的程度。运行下面的命令，可以查看你正在使用的 Node 环境对 ES6 的支持程度。 $ npm install -g es-checker $ es-checker ========================================= Passes 24 feature Dectations Your runtime supports 57% of ECMAScript 6 ========================================= ES6新特性let和const关键字 可以把let看成是var，但是let定义的变量被限定在了特定范围内才能使用，而离开了这个范围则无效。const很直观，用来定义常量，定义的时候必须初始化，不能留到以后再赋值，且与let相同，不存在声明提升，不可重复声明，只在声明所在的块级作用域内有效。more for(let i = 0; i &lt; 3; i++)console.log(i); // 0,1,2 console.log(i); // undefined,严格模式下会报错 箭头操作符 ES6中新增加了箭头操作符 =&gt; 简化了函数function的书写。操作符左边为输入的参数，而右边则是进行的操作以及返回的值：Inputs =&gt; outputsjs中的回调函数，每次都需要写function，而引入箭头操作符后可以方便的回调了： // 数组遍历的几种方法 var arr = [1,2,3]; // 传统写法 arr.forEach(function(v,i,a){ console.log(v); }) // ES6 arr.forEach(v => console.log(v)); // for of for(v of arr){ console.log(v); } 类的支持 ES6中添加了对类的支持，引入了class关键字（之前就是保留字），js本身就是面向对象的，ES6中提供的类实际上只是js原型模式的包装。而现在提供原生的class支持后，有两个好处： 1.对象的创建、继承就更加直观了， 2.父类方法的调用、实例化、静态方法和构造函数等概念都更加形象化。 class Animal { // es6中新的构造器 constructor(name){ this.name = name; } // 实例方法 sayName(){ console.log('my name is' + this.name); } } // 类的继承 class Programmer extends Animal{ constructor(name){ // 直接调用父类的构造器进行初始化 super(name); } // 自己的方法 program(){ console.log('我是一只老鼠'); } } // 测试 var animal = new Animal('Tom'); animal.sayname(); // my name is Tom; var aniaml2 = new Programmer('Jerry'); // 父类所有的方法，继承者都可以打点调用 animal2.sayName(); // my name is Jerry; animal2.program(); // 我是一只老鼠 for of 值遍历 for in循环用于遍历数组、类数组或对象，ES6中新引入的for of循环功能相似，不同的是每次循环它提供的不是序号而是值。 var arr = [1,2,3]; for(v in arr){ console.log(v); // 0,1,2 输出的是索引 } for(v of arr){ console.log(v); // 1,2,3 输出的是值 } Promise Promise是处理异步操作的一种模式，之前在很多三方库中有实现，比如jQuery的deferred对象，当你发起一个异步请求，并绑定了.wnhe()，.done()等事件处理程序时，其实就是在应用promise模式。 // 创建promise var promise = new Promise(function(resolve,reject){ if(/*条件语句*/){ resolve('yes'); }else{ reject(Error('no')); } }) // 绑定处理程序 promise.then(function(result){ // promise成功执行的语句 console.log(result); // yes },function(err){ // promise失败执行的语句 console.log(err); // no }) 增强的对象字面量 ES6中对象字面量增强了，写法更加简洁与灵活，同时在定义对象的时候能够做更多的事情，具体表现： 可以在对象字面量里面定义原型 定义方法可以不用function关键字 直接调用父类方法 与上面提到的类的概念更加吻合，编写js面向对象时更加方便。 // 通过对象字面量创建对象 var human = { breathe() { console.log('呼吸...'); } }; var worker = { // 设置此对象的原型为human，相当于继承human __proto__ : human, company : 'BAT', work() { console.log('我在工作...'); } }; human.breathe(); // 呼吸... // 调用继承来的方法 worker.breathe(); // 呼吸... worker.work(); // 我在工作... 默认参数值 现在可以在定义函数的时候指定参数的默认值 function sayHello(name){ // 传统方式用或操作符来完成 var name = name || 'Tom'; console.log('Hello' + name); } // ES6的形式： function sayHello2(name='Jerry'){ console.log(`Hello ${name}`); // 双反引号``是es6中的字符串模板，$配合{}来使用 } sayHello(); // Hello Tom sayHello('汤姆'); // Hello 汤姆 sayHello2(); // Hello Jerry sayHello2('杰瑞'); // Hello 杰瑞 参考资料ECMAScript 6 入门 - 阮一峰]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSocket与Socket.io的理解]]></title>
    <url>%2F2017%2F05%2F19%2FWebSocket%E4%B8%8ESocket.io%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[WebSocket protocol是HTML5一种新的协议。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 HTTP设计的时候，比如浏览器直接发出请求，服务器才能响应。如果浏览器不发出request请求，服务器是不能主动找到浏览器，传输一些数据的。也就是说：浏览器必须主动请求，服务器才会发出响应。 但是现在的web页面，对实时的要求很高：web看股票、篮球比赛图文直播、聊天室、站内信等等。现在的做法基本都是长轮询，用通俗易懂的话来说，就是客户端不停的（setInterval）向服务器发送请求以获取最新的数据信息。这里的“不停”其实是有停止的，只是我们人眼无法分辨是否停止，它只是一种快速的停下然后又立即开始连接而已。浏览器每隔比如20秒都问一下服务器，有没有人给我发站内信。服务器是不能有新消息就主动通知浏览器的。 HTML5有了一个叫做websocket的协议，允许服务器主动发出通知。在 WebSocket API，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。在此WebSocket 协议中，为我们实现即时服务带来了两大好处： Header互相沟通的Header是很小的-大概只有 2 Bytes Server Push服务器的推送，服务器不再被动的接收到浏览器的request之后才返回数据，而是在有新数据时就主动推送给浏览器。websocket需要浏览器足够新，IE10+。服务器也要足够新，NodeJS天生就支持。 为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。 接下来谈谈socket.io。它是一个NodeJS用的npm包，简化了websocket的程序开发。不用socket.io也能开发websocket但是极其复杂，比如要设置HTTP头等等。下面是简单的demo。 app.js: var express = require('express'); var app = express(); var http = require('http').Server(app); //服务器端存在了一个io对象： var io = require("socket.io")(http); app.use(express.static("public")); app.get('/', function(req, res){ res.sendFile(__dirname + "/index.html"); }); //增加了一个中间件： io.on("connect",function(socket){ //服务器端出现了一个socket对象 console.log("有人connect了！~~"); socket.on("ltxx",function(info){ console.log(info); }); }); http.listen(3000, function(){ console.log('监听3000端口'); }); index.html: &lt;!doctype html> &lt;html> &lt;head> &lt;title>Socket.IO chat&lt;/title> &lt;/head> &lt;body> &lt;ul id="messages"> &lt;/ul> &lt;form action=""> &lt;input id="m" /> &lt;button>发布&lt;/button> &lt;/form> &lt;script type="text/javascript" src="/socket.io/socket.io.js">&lt;/script> &lt;script src="/jquery-1.12.3.min.js">&lt;/script> &lt;script> var socket = io(); $("button").click(function(){ //socket.emit(信息名字,信息值) socket.emit('ltxx', $('#m').val()); //清空文本框 $('#m').val(''); return false; }) &lt;/script> &lt;/body> &lt;/html> 浏览器emit了信息，服务器就能listen到。服务器listen使用on函数。 服务器要把自己收到的信息，再次broadcast出去，然后让所有的html页面都能够收听服务器的广播即可。]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 6 -let命令]]></title>
    <url>%2F2017%2F05%2F15%2FECMAScript%206%20-let%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 基本用法{ let a = 10; var b = 1; } a // ReferenceError: a is not defined. b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。 for循环的计数器，就很合适使用let命令。 for (let i = 0; i &lt; 10; i++) {} console.log(i); //ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。 var a = []; for (var i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 10 上面代码中，变量i是var声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的function在运行时，会通过闭包读到这同一个变量i，导致最后输出的是最后一轮的i的值，也就是10。 而如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。 var a = []; for (let i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 另外，for循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。 for (let i = 0; i &lt; 3; i++) { let i = 'abc'; console.log(i); } // abc // abc // abc 上面代码输出了3次abc，这表明函数内部的变量i和外部的变量i是分离的。 参考资料ECMAScript 6 入门 - 阮一峰]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
</search>