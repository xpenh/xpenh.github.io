<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[WebSocket与Socket.io的理解]]></title>
      <url>/2017/05/19/WebSocket%E4%B8%8ESocket.io%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>WebSocket protocol是HTML5一种新的协议。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</p>
<p><img src="http://i4.buimg.com/1949/4006b9c9772796b4.png" alt="scoket"></p>
<p>HTTP设计的时候，比如浏览器直接发出请求，服务器才能响应。如果浏览器不发出request请求，服务器是不能主动找到浏览器，传输一些数据的。也就是说：浏览器必须主动请求，服务器才会发出响应。</p>
<p>但是现在的web页面，对实时的要求很高：web看股票、篮球比赛图文直播、聊天室、站内信等等。<br>现在的做法基本都是长轮询，用通俗易懂的话来说，就是客户端不停的（setInterval）向服务器发送请求以获取最新的数据信息。这里的“不停”其实是有停止的，只是我们人眼无法分辨是否停止，它只是一种快速的停下然后又立即开始连接而已。浏览器每隔比如20秒都问一下服务器，有没有人给我发站内信。服务器是不能有新消息就主动通知浏览器的。</p>
<p>HTML5有了一个叫做websocket的协议，允许服务器主动发出通知。<br>在 WebSocket API，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。在此WebSocket 协议中，为我们实现即时服务带来了两大好处：</p>
<ol>
<li><font color="#36f">Header</font><br>互相沟通的Header是很小的-大概只有 2 Bytes</li>
<li><font color="#36f">Server Push</font><br>服务器的推送，服务器不再被动的接收到浏览器的request之后才返回数据，而是在有新数据时就主动推送给浏览器。<br>websocket需要浏览器足够新，IE10+。服务器也要足够新，NodeJS天生就支持。</li>
</ol>
<p>为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。</p>
<p>接下来谈谈socket.io。它是一个NodeJS用的npm包，简化了websocket的程序开发。不用socket.io也能开发websocket但是极其复杂，比如要设置HTTP头等等。下面是简单的demo。</p>
<p>app.js:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var express = require(<span class="string">'express'</span>);</div><div class="line">var app = express();</div><div class="line">var http = require(<span class="string">'http'</span>).Server(app);</div><div class="line">//服务器端存在了一个io对象：</div><div class="line">var io = require(<span class="string">"socket.io"</span>)(http);</div><div class="line"></div><div class="line">app.use(express.static(<span class="string">"public"</span>));</div><div class="line"></div><div class="line">app.get(<span class="string">'/'</span>, <span class="keyword">function</span>(req, res)&#123;</div><div class="line">  res.sendFile(__dirname + <span class="string">"/index.html"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">//增加了一个中间件：</div><div class="line">io.on(<span class="string">"connect"</span>,<span class="keyword">function</span>(socket)&#123;</div><div class="line">  //服务器端出现了一个socket对象</div><div class="line">  console.log(<span class="string">"有人connect了！~~"</span>);</div><div class="line"></div><div class="line">  socket.on(<span class="string">"ltxx"</span>,<span class="keyword">function</span>(info)&#123;</div><div class="line">      console.log(info);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">http.listen(3000, <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">  console.log(<span class="string">'监听3000端口'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>index.html:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;!doctype html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;title&gt;Socket.IO chat&lt;/title&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">    &lt;ul id=<span class="string">"messages"</span>&gt;</div><div class="line">    &lt;/ul&gt;</div><div class="line">    &lt;form action=<span class="string">""</span>&gt;</div><div class="line">      &lt;input id=<span class="string">"m"</span>  /&gt;</div><div class="line">      &lt;button&gt;发布&lt;/button&gt;</div><div class="line">    &lt;/form&gt;</div><div class="line"></div><div class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"/socket.io/socket.io.js"</span>&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=<span class="string">"/jquery-1.12.3.min.js"</span>&gt;&lt;/script&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">      var socket = io();</div><div class="line">      $(<span class="string">"button"</span>).click(<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">        //socket.emit(信息名字,信息值)</div><div class="line">        socket.emit(<span class="string">'ltxx'</span>, $(<span class="string">'#m'</span>).val());</div><div class="line"></div><div class="line">        //清空文本框</div><div class="line">        $(<span class="string">'#m'</span>).val(<span class="string">''</span>);</div><div class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">      &#125;)</div><div class="line">    &lt;/script&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>浏览器emit了信息，服务器就能listen到。服务器listen使用on函数。</p>
<p>服务器要把自己收到的信息，再次broadcast出去，然后让所有的html页面都能够收听服务器的广播即可。</p>
<p><img src="http://i4.buimg.com/1949/16cebd69deef1eae.png" alt="scoket"></p>
]]></content>
      
        <categories>
            
            <category> html5 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> html </tag>
            
            <tag> html5 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[学习 -ECMAScript 6 -let命令]]></title>
      <url>/2017/05/15/%E5%AD%A6%E4%B9%A0%20-ECMAScript%206%20-let%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ES6</a> 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="built_in">let</span> a = 10;</div><div class="line">  var b = 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">a // ReferenceError: a is not defined.</div><div class="line">b // 1</div></pre></td></tr></table></figure>
<p>上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。</p>
<p>for循环的计数器，就很合适使用let命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 10; i++) &#123;&#125;</div><div class="line"></div><div class="line">console.log(i);</div><div class="line">//ReferenceError: i is not defined</div></pre></td></tr></table></figure></p>
<p>上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。</p>
<p>下面的代码如果使用var，最后输出的是10。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = [];</div><div class="line"><span class="keyword">for</span> (var i = 0; i &lt; 10; i++) &#123;</div><div class="line">  a[i] = <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    console.log(i);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">a[6](); // 10</div></pre></td></tr></table></figure></p>
<p>上面代码中，变量i是var声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的function在运行时，会通过闭包读到这同一个变量i，导致最后输出的是最后一轮的i的值，也就是10。</p>
<p>而如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = [];</div><div class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 10; i++) &#123;</div><div class="line">  a[i] = <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    console.log(i);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">a[6](); // 6</div></pre></td></tr></table></figure></p>
<p>上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。</p>
<p>另外，for循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 3; i++) &#123;</div><div class="line">  <span class="built_in">let</span> i = <span class="string">'abc'</span>;</div><div class="line">  console.log(i);</div><div class="line">&#125;</div><div class="line">// abc</div><div class="line">// abc</div><div class="line">// abc</div></pre></td></tr></table></figure></p>
<p>上面代码输出了3次abc，这表明函数内部的变量i和外部的变量i是分离的。<br><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">更多ES6学习</a></p>
]]></content>
      
        <categories>
            
            <category> ES6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
