<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[十月]]></title>
    <url>%2F2017%2F10%2F11%2F%E5%8D%81%E6%9C%88%2F</url>
    <content type="text"><![CDATA[2017.10.11 用满满当当的行程，过完了翘首以盼的国庆长假。重庆和西安的几天还是过的蛮开心的，除了人却也回味不起什么，相比还是更热爱家乡一些，连新换的2路汽车都能让我念上好一会儿。 老天爷总是想给你顺畅的旅途添点儿堵，让你感受到生活的意义。返京的途中一路头疼一路雨，到家想起明儿一早要上班，麻溜儿地收(扔)拾(出)了行李，随意冲了个澡，抱着脑袋便睡了觉，然后第二天下班回来就发现屋子像被洗劫了一番。 可能是因为充实的缘故，并没有犯上所谓的节后综合症。反而有点儿想上班的感觉，没办法，工作使我快乐。早晨刚来道了声早，智超说：ph啊，咱们该约饭了。想了想是啊一个月过去了，又想起昨儿通知下周要做季度PPT总结，又倏而觉得一个季度过去了，算起来距离春节也不过五个月了，认真起来的时候时间总是过得极快，而我这半年，很认真。接下来就该好好利用即将到来的双11，让秋冬的生活过得更快乐、更充实一些。 （Don’t worry, there will be cats.） 一场秋雨一场寒。十月的北京，真冷。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[满口]]></title>
    <url>%2F2017%2F08%2F07%2F%E6%BB%A1%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[2017.08.07 快到吃饭时间了。叨叨两句。 微博又关闭了几个接口，导致我的IFTTT已经快落灰了，虽然有一段时间了不过还是想祝福一句 “新浪吃枣药丸” 。日常屏蔽了几个在首页里出现的视演技和职业道德如无物的狗屁小鲜肉（这是会员唯一的好处），消息通知关闭了 “微博热点” 然而每天还是有一些垃圾出现在通知栏，今天又发现手机端的广告无法关闭的情况。用户体验应是互联网产品的根本，而不是踏脚石，微博，你说你怎么就是不注重呢？ 要不要回朋友圈？ 现在做技术不能光敲代码了还得练一副好口才，哦对，还得会写一手好文章。前端圈又吵架了，大漠穷秋带着Angular鄙视尤雨溪的Vue，微博知乎里各路大V忙着站队转发推波助澜互相怼，小白们也跟着上蹿下跳是真热闹，吵到今天大漠穷秋发声明又是致歉删文章又是离职的，而闹剧却还是会持续下去，你们何苦呢，又图什么。我一直觉得前端应该低调一些，而不是现在这样像小丑一样被同行看热闹。 周五晚现学现做了两个菜，一个人吃完了。周六去看了 “青年100的7周年展览” ，展品很贴近生活。适合独自观看。周日白天洗了衣服收拾了屋子，晚上做了蛋炒饭吃。 周一 一大早闲到现在。 你看，这就是生活的样子。 吃饭。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用flexible完成H5终端适配]]></title>
    <url>%2F2017%2F08%2F03%2F%E4%BD%BF%E7%94%A8flexible%E5%AE%8C%E6%88%90H5%E7%BB%88%E7%AB%AF%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[昨天做了一个H5的分享页，由于页面本身需求不大所以没有考虑bootstrap，而是采用了淘宝的flexible方案。 使用方法在页面顶部引入依赖库： &lt;script src="http://g.tbcdn.cn/mtb/lib-flexible/{{version}}/??flexible_css.js,flexible.js">&lt;/script> 注意要在所有资源加载之前执行这个js，之后页面的元素，都可以用rem来设置，而html上的font-size就是rem的基准像素。 设计图中的px转换成rem元素的尺寸换算，只需要原始px值除以rem基准值。 字体不建议使用rem字体仍然使用px为单位。如果项目中有标题之类的，可以使用rem。 其他问题关于文本和图片的居中html: &lt;a href="" class="open_btn"> &lt;h2>打开映社，发现更多精彩&lt;/h2> &lt;img src="images/open.png" alt=""> &lt;/a> css: .open_btn{ display: block; color: #FFF; background-color: #393a3a; height: 1.26rem; font-size: 0.41rem; margin: 0.3rem 0.37rem 2.06rem 0.37rem; border-radius: 0.11rem; text-align: center; line-height: 1.26rem; } .open_btn h2{ line-height: 1.26rem; display: inline-block; vertical-align: middle; } .open_btn img{ width: 0.44rem; height: 0.44rem; vertical-align: middle; }]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>技术项</tag>
        <tag>html</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 6 -const命令]]></title>
    <url>%2F2017%2F06%2F06%2FECMAScript%206%20-const%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[ES6 中，const声明一个只读的常量。一旦声明，常量的值就不能改变。 基本用法const PI = 3.1415; PI // 3.1415 PI = 3; // TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 const foo; // SyntaxError: Missing initializer in const declaration 面代码表示，对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 if (true) { const MAX = 5; } MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 if (true) { console.log(MAX); // ReferenceError const MAX = 5; } 上面代码在常量MAX声明之前就调用，结果报错。 const声明的常量，也与let一样不可重复声明。 var message = "Hello!"; let age = 24; // 以下两行都会报错 const message = "Goodbye!"; const age = 25; 本质 const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 例子1： const foo = {}; // 为 foo 添加一个属性，可以成功 foo.prop = 012; foo.prop // 012 // 将 foo 指向另一个对象，就会报错 foo = {}; // TypeError: "foo" is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 例子2： const a = []; a.push('Hello'); // 可执行 a.length = 0; // 可执行 a = ['Dave']; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。 如果要冻结对象，应该使用Object.freeze方法。 const foo = Object.freeze({}); // 常规模式时，下面一行不起作用； // 严格模式时，该行会报错 foo.prop = 012; 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用。 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。 var constantize = (obj) => { Object.freeze(obj); Object.keys(obj).forEach( (key, i) => { if ( typeof obj[key] === 'object' ) { constantize( obj[key] ); } }); }; ES6声明变量的6种方法 ES5 只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有6种声明变量的方法。 更多ES6新特性 参考资料ECMAScript 6 入门 - 阮一峰]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
        <tag>技术项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 6 新特性]]></title>
    <url>%2F2017%2F05%2F25%2FECMAScript%206%20%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[部署进度 目前ES6的支持度已经越来越高了，超过90%的 ES6 语法特性都实现了。关于各大浏览器的最新版本，对 ES6 的支持可以查看kangax.github.io/es5-compat-table/es6/。 Node 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。它对 ES6 的支持度更高。除了那些默认打开的功能，还有一些语法功能已经实现了，但是默认没有打开。使用下面的命令，可以查看 Node 已经实现的 ES6 特性。 $ node --v8-options | grep harmony 上面命令的输出结果，会因为版本的不同而有所不同。 使用阮一峰写的工具ES-Checker用来检查各种运行环境对 ES6 的支持情况。访问ruanyf.github.io/es-checker,可以看到您的浏览器支持 ES6 的程度。运行下面的命令，可以查看你正在使用的 Node 环境对 ES6 的支持程度。 $ npm install -g es-checker $ es-checker ========================================= Passes 24 feature Dectations Your runtime supports 57% of ECMAScript 6 ========================================= ES6新特性let和const关键字 可以把let看成是var，但是let定义的变量被限定在了特定范围内才能使用，而离开了这个范围则无效。const很直观，用来定义常量，定义的时候必须初始化，不能留到以后再赋值，且与let相同，不存在声明提升，不可重复声明，只在声明所在的块级作用域内有效。more for(let i = 0; i &lt; 3; i++)console.log(i); // 0,1,2 console.log(i); // undefined,严格模式下会报错 箭头操作符 ES6中新增加了箭头操作符 =&gt; 简化了函数function的书写。操作符左边为输入的参数，而右边则是进行的操作以及返回的值：Inputs =&gt; outputsjs中的回调函数，每次都需要写function，而引入箭头操作符后可以方便的回调了： // 数组遍历的几种方法 var arr = [1,2,3]; // 传统写法 arr.forEach(function(v,i,a){ console.log(v); }) // ES6 arr.forEach(v => console.log(v)); // for of for(v of arr){ console.log(v); } 类的支持 ES6中添加了对类的支持，引入了class关键字（之前就是保留字），js本身就是面向对象的，ES6中提供的类实际上只是js原型模式的包装。而现在提供原生的class支持后，有两个好处： 1.对象的创建、继承就更加直观了， 2.父类方法的调用、实例化、静态方法和构造函数等概念都更加形象化。 class Animal { // es6中新的构造器 constructor(name){ this.name = name; } // 实例方法 sayName(){ console.log('my name is' + this.name); } } // 类的继承 class Programmer extends Animal{ constructor(name){ // 直接调用父类的构造器进行初始化 super(name); } // 自己的方法 program(){ console.log('我是一只老鼠'); } } // 测试 var animal = new Animal('Tom'); animal.sayname(); // my name is Tom; var aniaml2 = new Programmer('Jerry'); // 父类所有的方法，继承者都可以打点调用 animal2.sayName(); // my name is Jerry; animal2.program(); // 我是一只老鼠 for of 值遍历 for in循环用于遍历数组、类数组或对象，ES6中新引入的for of循环功能相似，不同的是每次循环它提供的不是序号而是值。 var arr = [1,2,3]; for(v in arr){ console.log(v); // 0,1,2 输出的是索引 } for(v of arr){ console.log(v); // 1,2,3 输出的是值 } Promise Promise是处理异步操作的一种模式，之前在很多三方库中有实现，比如jQuery的deferred对象，当你发起一个异步请求，并绑定了.wnhe()，.done()等事件处理程序时，其实就是在应用promise模式。 // 创建promise var promise = new Promise(function(resolve,reject){ if(/*条件语句*/){ resolve('yes'); }else{ reject(Error('no')); } }) // 绑定处理程序 promise.then(function(result){ // promise成功执行的语句 console.log(result); // yes },function(err){ // promise失败执行的语句 console.log(err); // no }) 增强的对象字面量 ES6中对象字面量增强了，写法更加简洁与灵活，同时在定义对象的时候能够做更多的事情，具体表现： 可以在对象字面量里面定义原型 定义方法可以不用function关键字 直接调用父类方法 与上面提到的类的概念更加吻合，编写js面向对象时更加方便。 // 通过对象字面量创建对象 var human = { breathe() { console.log('呼吸...'); } }; var worker = { // 设置此对象的原型为human，相当于继承human __proto__ : human, company : 'BAT', work() { console.log('我在工作...'); } }; human.breathe(); // 呼吸... // 调用继承来的方法 worker.breathe(); // 呼吸... worker.work(); // 我在工作... 默认参数值 现在可以在定义函数的时候指定参数的默认值 function sayHello(name){ // 传统方式用或操作符来完成 var name = name || 'Tom'; console.log('Hello' + name); } // ES6的形式： function sayHello2(name='Jerry'){ console.log(`Hello ${name}`); // 双反引号``是es6中的字符串模板，$配合{}来使用 } sayHello(); // Hello Tom sayHello('汤姆'); // Hello 汤姆 sayHello2(); // Hello Jerry sayHello2('杰瑞'); // Hello 杰瑞 参考资料ECMAScript 6 入门 - 阮一峰]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
        <tag>技术项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSocket与Socket.io的理解]]></title>
    <url>%2F2017%2F05%2F19%2FWebSocket%E4%B8%8ESocket.io%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[WebSocket protocol是HTML5一种新的协议。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 HTTP设计的时候，比如浏览器直接发出请求，服务器才能响应。如果浏览器不发出request请求，服务器是不能主动找到浏览器，传输一些数据的。也就是说：浏览器必须主动请求，服务器才会发出响应。 但是现在的web页面，对实时的要求很高：web看股票、篮球比赛图文直播、聊天室、站内信等等。现在的做法基本都是长轮询，用通俗易懂的话来说，就是客户端不停的（setInterval）向服务器发送请求以获取最新的数据信息。这里的“不停”其实是有停止的，只是我们人眼无法分辨是否停止，它只是一种快速的停下然后又立即开始连接而已。浏览器每隔比如20秒都问一下服务器，有没有人给我发站内信。服务器是不能有新消息就主动通知浏览器的。 HTML5有了一个叫做websocket的协议，允许服务器主动发出通知。在 WebSocket API，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。在此WebSocket 协议中，为我们实现即时服务带来了两大好处： Header互相沟通的Header是很小的-大概只有 2 Bytes Server Push服务器的推送，服务器不再被动的接收到浏览器的request之后才返回数据，而是在有新数据时就主动推送给浏览器。websocket需要浏览器足够新，IE10+。服务器也要足够新，NodeJS天生就支持。 为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。 接下来谈谈socket.io。它是一个NodeJS用的npm包，简化了websocket的程序开发。不用socket.io也能开发websocket但是极其复杂，比如要设置HTTP头等等。下面是简单的demo。 app.js: var express = require('express'); var app = express(); var http = require('http').Server(app); //服务器端存在了一个io对象： var io = require("socket.io")(http); app.use(express.static("public")); app.get('/', function(req, res){ res.sendFile(__dirname + "/index.html"); }); //增加了一个中间件： io.on("connect",function(socket){ //服务器端出现了一个socket对象 console.log("有人connect了！~~"); socket.on("ltxx",function(info){ console.log(info); }); }); http.listen(3000, function(){ console.log('监听3000端口'); }); index.html: &lt;!doctype html> &lt;html> &lt;head> &lt;title>Socket.IO chat&lt;/title> &lt;/head> &lt;body> &lt;ul id="messages"> &lt;/ul> &lt;form action=""> &lt;input id="m" /> &lt;button>发布&lt;/button> &lt;/form> &lt;script type="text/javascript" src="/socket.io/socket.io.js">&lt;/script> &lt;script src="/jquery-1.12.3.min.js">&lt;/script> &lt;script> var socket = io(); $("button").click(function(){ //socket.emit(信息名字,信息值) socket.emit('ltxx', $('#m').val()); //清空文本框 $('#m').val(''); return false; }) &lt;/script> &lt;/body> &lt;/html> 浏览器emit了信息，服务器就能listen到。服务器listen使用on函数。 服务器要把自己收到的信息，再次broadcast出去，然后让所有的html页面都能够收听服务器的广播即可。]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>技术项</tag>
        <tag>html</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 6 -let命令]]></title>
    <url>%2F2017%2F05%2F15%2FECMAScript%206%20-let%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 基本用法{ let a = 10; var b = 1; } a // ReferenceError: a is not defined. b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。 for循环的计数器，就很合适使用let命令。 for (let i = 0; i &lt; 10; i++) {} console.log(i); //ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。 var a = []; for (var i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 10 上面代码中，变量i是var声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的function在运行时，会通过闭包读到这同一个变量i，导致最后输出的是最后一轮的i的值，也就是10。 而如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。 var a = []; for (let i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 另外，for循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。 for (let i = 0; i &lt; 3; i++) { let i = 'abc'; console.log(i); } // abc // abc // abc 上面代码输出了3次abc，这表明函数内部的变量i和外部的变量i是分离的。 不存在变量声明提升 var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。 为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 // var console.log(foo); // undefined var foo = 2; // let console.log(bar); // 会报错：ReferenceError let bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 // 会报错 function () { let a = 10; var a = 1; } // 会报错 function () { let a = 10; let a = 1; } 因此，不能在函数内部重新声明参数。 function func(age) { let age; // 会报错 } function func(age) { { let age; // 不报错 } } 更多ES6新特性 参考资料ECMAScript 6 入门 - 阮一峰]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
        <tag>技术项</tag>
      </tags>
  </entry>
</search>